#include <GLES2/gl2.h>
#include <EGL/egl.h>

#include <iostream>
#include <vector>

#define STRINGIFY(x) #x

static const int WIDTH = 800;
static const int HEIGHT = 600;

static const EGLint configAttribs[] = {
  EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
  EGL_BLUE_SIZE, 8,
  EGL_GREEN_SIZE, 8,
  EGL_RED_SIZE, 8,
  EGL_DEPTH_SIZE, 8,

  // Uncomment the following to enable MSAA 
  //EGL_SAMPLE_BUFFERS, 1, // <-- Must be set to 1 to enable multisampling!
  //EGL_SAMPLES, 4, // <-- Number of samples

  // Uncomment the following to enable stencil buffer
  //EGL_STENCIL_SIZE, 1,

  EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
  EGL_NONE
};

static const EGLint pbufferAttribs[] = {
  EGL_WIDTH, WIDTH,
  EGL_HEIGHT, HEIGHT,
  EGL_NONE
};

static const EGLint contextAttribs[] = {
  EGL_CONTEXT_CLIENT_VERSION, 2,
  EGL_NONE
};

static bool check(GLuint object, GLenum to_check, void (*glGet__iv)(GLuint, GLenum, GLint*), void (*glGet__infoLog)(GLuint, GLsizei, GLsizei*, GLchar*), void (*glDelete__)(GLuint))
{
  GLint success = 0;
  glGet__iv(object, to_check, &success);
  if (success == GL_FALSE) {
	GLint max_length = 0;
	glGet__iv(object, GL_INFO_LOG_LENGTH, &max_length);

	char* error_log = new char[max_length];
	glGet__infoLog(object, max_length, NULL, error_log);

	std::cerr << "Error while compiling:" << std::endl << error_log;
	glDelete__(object); // Don't leak the object.
	free(error_log); // Don't leak the error log.
	return false;
  }
  return true;
}


static void load_image(char* filename)
{
  ILboolean success;
}

int main(int argc, char** argv)
{
  // Get an EGL valid display
  EGLDisplay display;
  display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
  if (display == EGL_NO_DISPLAY) {
	std::cerr << "Failed to get EGL Display" << std::endl
			  << "Error: " << eglGetError() << std::endl;
	return EXIT_FAILURE;
  }
  else {
	std::cerr << "Successfully get EGL Display." << std::endl;
  }

  
  // Create a connection to the display
  int minor, major;
  if (eglInitialize(display, &minor, &major) == EGL_FALSE) {
	std::cerr << "Failed to initialize EGL Display" << std::endl
			  << "Error: " << eglGetError() << std::endl;
	eglTerminate(display);
	return EXIT_FAILURE;
  }
  else {
	std::cerr << "Successfully intialized display (OpenGL ES version " << minor << "." << major << ")." << std::endl;
  }

  // OpenGL ES Config are used to specify things like multi sampling, channel size, stencil buffer usage, & more
  // See the doc: https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglChooseConfig.xhtml for more informations
  EGLConfig config;
  EGLint num_configs; 
  if (!eglChooseConfig(display, configAttribs, &config, 1, &num_configs)) {
	std::cerr << "Failed to choose EGL Config" << std::endl
			  << "Error: " << eglGetError() << std::endl;
	eglTerminate(display);
	return EXIT_FAILURE;
  }
  else {
	std::cerr << "Successfully choose OpenGL ES Config ("<< num_configs << ")." << std::endl;
  }

  // Creating an OpenGL Render Surface with surface attributes defined above.
  EGLSurface surface = eglCreatePbufferSurface(display, config, pbufferAttribs);
  if (surface == EGL_NO_SURFACE) {
	std::cerr << "Failed to create EGL Surface." << std::endl
			  << "Error: " << eglGetError() << std::endl;
  }
  else {
	std::cerr << "Successfully created OpenGL ES Surface." << std::endl;
  }

  eglBindAPI(EGL_OPENGL_API);
  EGLContext context = eglCreateContext(display, config, EGL_NO_CONTEXT, contextAttribs);
  if (context == EGL_NO_CONTEXT) {
	std::cerr << "Failed to create EGL Context." << std::endl
			  << "Error: " << eglGetError() << std::endl;
  }
  else {
	std::cerr << "Successfully created OpenGL ES Context." << std::endl;
  }

  //Bind context to surface
  eglMakeCurrent(display, surface, surface, context);

  // Create viewport and check if it has been created correctly
  glViewport(0, 0, WIDTH, HEIGHT);
  GLint viewport[4];
  glGetIntegerv(GL_VIEWPORT, viewport);

  if (viewport[2] != WIDTH || viewport[3] != HEIGHT) {
	std::cerr << "Failed to create the viewport. Size does not match (glViewport/glGetIntegerv not working)." << std::endl
			  << "OpenGL ES might be faulty!" << std::endl
			  << "If you are on Raspberry Pi, you should not updated EGL as it will install fake EGL." << std::endl;
	eglTerminate(display);
	return EXIT_FAILURE;
  }

  // Clear buffer and get ready to draw some things
  glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  // Create a shader program
  GLuint program = glCreateProgram();
  glUseProgram(program);

  const char* vertex_shader_code = STRINGIFY(
    attribute vec3 pos;

	void main(void)
	{
	  gl_Position = vec4(pos, 1.0);
	}
  );

  // Create sub shader: vertex shader
  GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
  glShaderSource(vertex_shader, 1, &vertex_shader_code, NULL);
  glCompileShader(vertex_shader);
  if (!check(vertex_shader, GL_COMPILE_STATUS, glGetShaderiv, glGetShaderInfoLog, glDeleteShader)) {
	std::cerr << "Failed to compile vertex shader." << std::endl;
	eglTerminate(display);
	return EXIT_FAILURE;
  }
  else {
	std::cerr << "Successfully compilated vertex shader." << std::endl;
  }

  const char* fragment_shader_code = STRINGIFY(
    uniform vec4 color;

	void main(void)
	{
	  gl_FragColor = color;
	}
  );

  // Create sub shader: fragment shader
  GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
  glShaderSource(fragment_shader, 1, &fragment_shader_code, NULL);
  glCompileShader(fragment_shader);
  if (!check(fragment_shader, GL_COMPILE_STATUS, glGetShaderiv, glGetShaderInfoLog, glDeleteShader)) {
	std::cerr << "Failed to compile fragment shader." << std::endl;
	eglTerminate(display);
	return EXIT_FAILURE;
  }
  else {
	std::cerr << "Successfully compilated fragment shader." << std::endl;
  }

  glAttachShader(program, vertex_shader);
  glAttachShader(program, fragment_shader);
  glLinkProgram(program);
  if (!check(program, GL_LINK_STATUS, glGetProgramiv, glGetProgramInfoLog, glDeleteProgram)) {
	std::cerr << "Failed to link program." << std::endl;
	eglTerminate(display);
	return EXIT_FAILURE;
  }
  else {
	std::cerr << "Successfully linked program." << std::endl;
  }
  
  glUseProgram(program);

 
  // Cleanup
  eglDestroyContext(display, context);
  eglDestroySurface(display, surface);
  eglTerminate(display);
  return EXIT_SUCCESS;
}
